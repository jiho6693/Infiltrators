// 전역: 렌더 모드와 배경을 BW로
let RENDER_MODE = 'glow';     // 'pixel'로 바꾸면 네모
document.getElementById('canvas').style.background = '#000';

// --- draw() 교체 ---
function draw(){
  // 어두운 잔상 (검정만)
  if((trailTick++%2)===0){
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,cvs.width,cvs.height);
  }

  if(RENDER_MODE==='pixel'){
    // 픽셀 모드: 흰색 단색 밝기
    for(let i=0;i<agents.length;i++){
      const a=agents[i]; if(a.dead) continue;
      const x=a.x*tile, y=a.y*tile;
      // 에너지 기반 밝기 (0~1) -> 30~95% 사이의 흰색 명도
      const l = 0.3 + Math.min(1, a.energy/60)*0.65;
      const L = Math.round(l*100);
      ctx.fillStyle = `hsl(0,0%,${L}%)`;  // = grayscale
      ctx.fillRect(x, y, tile, tile);
    }
    return;
  }

  // glow 모드: 흰→투명 그라디언트
  ctx.globalCompositeOperation = 'lighter';
  for(let i=0;i<agents.length;i++){
    const a=agents[i]; if(a.dead) continue;
    const cx = (a.x + 0.5)*tile, cy = (a.y + 0.5)*tile;
    const r  = tile*0.62;
    const e  = Math.max(0, Math.min(1, a.energy/60)); // 에너지 0~1 스케일

    // 중심부는 밝고(불투명), 가장자리는 투명
    const g = ctx.createRadialGradient(cx, cy, r*0.15, cx, cy, r);
    g.addColorStop(0.0, `rgba(255,255,255,${0.55+e*0.35})`);
    g.addColorStop(0.5, `rgba(255,255,255,${0.25+e*0.25})`);
    g.addColorStop(1.0, `rgba(255,255,255,0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, r*(0.9+e*0.3), 0, Math.PI*2);
    ctx.fill();

    // 얇은 림 (희미한 흰색선)
    ctx.globalAlpha = 0.12 + e*0.18;
    ctx.strokeStyle = `rgba(255,255,255,0.6)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(cx, cy, r*(0.65+e*0.25), 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  ctx.globalCompositeOperation = 'source-over';
}
