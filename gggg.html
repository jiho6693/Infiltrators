<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tierra-inspired — Intruder Cells (Modern Glow)</title>
<style>
  :root{ --bg:#0b0e12; --ink:#e6f0ff; --rule:#1a2433; }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.6 system-ui,-apple-system,"Noto Sans KR",Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #wrap{display:grid; grid-template-rows:auto 1fr; height:100vh}
  body.hide-ui header{display:none;}      /* 기본은 UI 숨김 */
  header{display:flex;gap:10px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--rule);flex-wrap:wrap}
  header h1{font-size:14px;margin:0;opacity:.9}
  .btn{padding:6px 10px;border:1px solid var(--rule);background:transparent;color:inherit;border-radius:10px;cursor:pointer}
  .btn:hover{opacity:.9}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  label{font-size:12px;opacity:.85}
  input[type=range]{accent-color:#7cc7ff}
  #canvas{display:block;width:100%;height:100%;background:#0d1117}
  .legend{font-size:12px;opacity:.7;margin-left:auto}
  .hint {position:fixed;right:12px;bottom:10px;font-size:12px;opacity:.6}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Intruder Cells</h1>
    <div class="row">
      <label>픽셀크기 <span id="pxLabel">20</span></label>
      <input id="px" type="range" min="6" max="40" step="2" value="20"/>

      <label>소멸 강도 <span id="extLabel">0.15</span></label>
      <input id="ext" type="range" min="0" max="1" step="0.05" value="0.15"/>

      <label>속도 <span id="speedLabel">1x</span></label>
      <input id="speed" type="range" min="0.25" max="3" step="0.25" value="1"/>

      <label>돌연변이 <span id="mutLabel">1%</span></label>
      <input id="mut" type="range" min="0" max="0.2" step="0.005" value="0.01"/>

      <label>밀도 <span id="seedLabel">15</span></label>
      <input id="seedCount" type="range" min="1" max="300" step="1" value="15"/>
    </div>
    <button class="btn" id="resetBtn">Reset</button>
    <button class="btn" id="intrudeBtn">침입자 투입</button>
    <div class="legend">U: UI 토글 · M: 렌더 모드 변경(글로우/픽셀) · 캔버스 클릭: 군집 생성</div>
  </header>
  <canvas id="canvas"></canvas>
</div>
<div class="hint">U = UI 표시/숨김 · M = 렌더모드</div>

<script>
(function(){
  // 처음엔 UI 숨김
  document.body.classList.add('hide-ui');

  const cvs = document.getElementById('canvas');
  const ctx = cvs.getContext('2d', { alpha:false });

  // ----- 렌더 모드: glow(기본) | pixel -----
  let RENDER_MODE = 'glow';

  // --- SIM params (extinction slider로 매핑) ---
  let tile = 20;                        // 기본 셀 표시 크기(글로우 반지름 기준)
  let MAX_DENSITY = 0.15;               // 전체 셀 대비 최대 개체 밀도
  let BASE_DRAIN = 2;                   // 1틱당 에너지 소모
  let REPL_COST = 0.6;                  // 복제 비용(부모 손실)
  let REPL_GATE = 0.5;                  // 복제 시도 확률 게이트
  let EAT_GAIN_MIN = 2, EAT_GAIN_MAX = 6;// 먹이량
  let CROWD_K = 6;                      // 과밀 사망 임계 이웃 수

  // --- Layout ---
  function headerH(){ return document.querySelector('header')?.offsetHeight || 0; }
  function resizeCanvas(){
    const dpr = Math.min(devicePixelRatio||1, 2);
    cvs.width = Math.floor(innerWidth * dpr);
    cvs.height = Math.floor((innerHeight - headerH()) * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', ()=>{ buildGrid(true); });

  // --- Grid & agents -------------------------------------------------
  let cols=0, rows=0, grid, agents=[];
  const N = () => cols*rows;
  const idx = (x,y)=> ( ( (y%rows)+rows)%rows )*cols + ( ( (x%cols)+cols)%cols ); // wrap

  // RNG
  let seed = (Math.random()*1e9)|0;
  function rand(){ seed ^= seed<<13; seed ^= seed>>>17; seed ^= seed<<5; return (seed>>>0)/4294967296; }
  function rint(n){ return Math.floor(rand()*n); }

  function buildGrid(keepSeeds){
    resizeCanvas();
    cols = Math.max(8, Math.floor(innerWidth / tile));
    rows = Math.max(8, Math.floor((innerHeight - headerH()) / tile));
    grid = new Int32Array(N()); grid.fill(-1); agents = [];
    if(keepSeeds){ randomSeeds(+seedEl.value); }
  }

  // Ambient energy (cheaper)
  function ambient(x,y){
    const n = Math.sin((x*12.9898 + y*78.233)*0.017) * 43758.5453;
    return Math.max(0, (n - Math.floor(n)) - 0.25); // 0..~0.75
  }

  // ISA ops
  const OPS = 11; // 0..10
  function newGenome(len=20){
    const g = new Uint8Array(len);
    for(let i=0;i<len;i++) g[i] = rint(OPS);
    g[rint(len)] = 5; // REPL bias
    g[rint(len)] = 8; // EAT bias
    return g;
  }
  function colorFromGenome(gen){ let h=0; for(let i=0;i<gen.length;i++) h = (h*131 + gen[i])>>>0; return h%360; }

  function spawn(x,y,gen){
    const maxAgents = Math.floor(N()*MAX_DENSITY);
    if(agents.length >= maxAgents) return -1; // hard cap
    const idAt = grid[idx(x,y)]; if(idAt!==-1) return -1;
    const a = { x,y, dir:rint(4), ip:0, gen:gen||newGenome(), energy: 30 + rint(40), age:0, hue:0 };
    a.hue = colorFromGenome(a.gen);
    const id = agents.length; agents.push(a); grid[idx(x,y)] = id; return id;
  }

  function ahead(a){ const d=a.dir; return d===0?[0,-1]: d===1?[1,0]: d===2?[0,1]:[-1,0]; }
  function tryMove(a,dx,dy){ const to=idx(a.x+dx,a.y+dy); if(grid[to]===-1){ grid[idx(a.x,a.y)] = -1; a.x+=dx; a.y+=dy; grid[idx(a.x,a.y)] = agents.indexOf(a); return true; } return false; }

  function mutate(gen, rate){ const g=gen.slice(); for(let i=0;i<g.length;i++) if(rand()<rate) g[i]=rint(OPS); return g; }

  let MUT_RATE = 0.01;
  function step(a){
    if(a.energy<=0){ kill(a); return; }
    a.age++; a.energy -= BASE_DRAIN;

    // crowding death (Moore neighborhood)
    const nx = [-1,0,1,-1,1,-1,0,1]; const ny=[-1,-1,-1,0,0,1,1,1];
    let neighbors=0; for(let k=0;k<8;k++){ if(grid[idx(a.x+nx[k], a.y+ny[k])]!==-1) neighbors++; }
    if(neighbors>=CROWD_K && rand()<0.2){ kill(a); return; }

    const op = a.gen[a.ip % a.gen.length];
    switch(op){
      case 1:{ const [dx,dy]=ahead(a); tryMove(a,dx,dy); break; } // FWD
      case 2: a.dir=(a.dir+3)&3; break; // L
      case 3: a.dir=(a.dir+1)&3; break; // R
      case 4:{ const [dx,dy]=ahead(a); const empty=(grid[idx(a.x+dx,a.y+dy)]===-1); if(empty) a.ip=(a.ip+1)%a.gen.length; break; } // LOOK
      case 5:{ // REPL (gated)
        if(rand()<REPL_GATE && a.energy>40){ const [dx,dy]=ahead(a); const spot=idx(a.x+dx,a.y+dy);
          if(grid[spot]===-1){ const child=spawn(a.x+dx,a.y+dy, mutate(a.gen, MUT_RATE)); if(child!==-1){
            const give = Math.floor(a.energy*(1-REPL_COST)); agents[child].energy = give; a.energy = Math.max(10, a.energy - give);
          }}}
        break;
      }
      case 6: a.gen = mutate(a.gen, MUT_RATE*0.5); a.hue=colorFromGenome(a.gen); break; // MUT
      case 7: a.ip = (a.ip + 2 + (a.gen[(a.ip+1)%a.gen.length]||1)) % a.gen.length; break; // JUMP
      case 8: a.energy += Math.floor(EAT_GAIN_MIN + (EAT_GAIN_MAX-EAT_GAIN_MIN)*ambient(a.x,a.y)); break; // EAT
      case 9: break; // WAIT
      case 10: kill(a); return; // DIE
      default: /* NOP */
    }
    a.ip = (a.ip + 1) % a.gen.length;

    // late death
    if(a.age>1200 && rand()<0.003) kill(a);
  }

  function kill(a){ const id = grid[idx(a.x,a.y)]; if(id!==-1) grid[idx(a.x,a.y)] = -1; a.dead=true; a.energy=-1; }

  function compact(){
    const newAgents=[]; grid.fill(-1);
    for(let i=0;i<agents.length;i++){ const a=agents[i]; if(!a.dead){ grid[idx(a.x,a.y)] = newAgents.length; newAgents.push(a); } }
    agents = newAgents;
  }

  function seedBlob(cx,cy,count){ for(let i=0;i<count;i++){ const x=cx+rint(7)-3, y=cy+rint(7)-3; spawn(x,y, newGenome(14+rint(10))); } }
  function randomSeeds(n=40){ for(let i=0;i<n;i++) seedBlob(rint(cols), rint(rows), 1+rint(2)); }

  // --- 렌더 ------------------------------------------------
  let trailTick=0;
  function draw(){
    // 부드러운 잔상
    if((trailTick++%2)===0){
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle='rgba(13,17,23,0.35)'; // #0d1117
      ctx.fillRect(0,0,cvs.width,cvs.height);
    }

    if(RENDER_MODE==='pixel'){
      for(let i=0;i<agents.length;i++){
        const a=agents[i]; if(a.dead) continue; const x=a.x*tile, y=a.y*tile;
        ctx.fillStyle = `hsl(${a.hue},70%,${40 + Math.min(30, a.energy/5)}%)`;
        ctx.fillRect(x, y, tile, tile);
      }
      return;
    }

    // glow 모드
    ctx.globalCompositeOperation = 'lighter'; // 색이 겹치며 빛나는 효과
    for(let i=0;i<agents.length;i++){
      const a=agents[i]; if(a.dead) continue;
      const cx = (a.x + 0.5)*tile, cy = (a.y + 0.5)*tile;
      const r  = tile*0.62;                       // 기본 반경
      const e  = Math.max(0, Math.min(1, a.energy/60));
      const g  = ctx.createRadialGradient(cx, cy, r*0.15, cx, cy, r);
      const h  = a.hue;
      g.addColorStop(0.0, `hsla(${h},90%,70%,${0.55+e*0.35})`);
      g.addColorStop(0.5, `hsla(${h},85%,55%,${0.25+e*0.25})`);
      g.addColorStop(1.0, `hsla(${h},70%,40%,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(cx, cy, r*(0.9+e*0.3), 0, Math.PI*2);
      ctx.fill();

      // 얇은 림 하이라이트
      ctx.globalAlpha = 0.15 + e*0.2;
      ctx.strokeStyle = `hsla(${h},90%,85%,0.6)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, r*(0.65+e*0.25), 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  // --- main loop ------------------------------------------------
  let SPEED=1.0, frame=0;
  function loop(){
    requestAnimationFrame(loop);
    const iters = Math.max(1, Math.floor(SPEED));
    for(let r=0;r<iters;r++){
      const len=agents.length; const stepCount = Math.min(len, Math.ceil(len*0.6));
      for(let k=0;k<stepCount;k++){ const i=(k*2+frame)%len; step(agents[i]); }
      if((frame%30)===0) compact();
    }
    draw(); frame++;
  }

  // --- Extinction control -------------------------------------------
  const lerp = (a,b,t)=> a + (b-a)*t;
  function applyExtinction(t){
    // t: 0(부드러운 생장) → 1(공격적 소멸)
    BASE_DRAIN   = Math.round(lerp(1, 4, t));
    EAT_GAIN_MIN = Math.round(lerp(6, 1, t));
    EAT_GAIN_MAX = Math.round(lerp(12, 6, t));
    REPL_COST    = lerp(0.3, 0.75, t);      // 부모 손실↑
    REPL_GATE    = lerp(0.8, 0.35, t);      // 복제 시도↓
    CROWD_K      = Math.round(lerp(7, 4, t));
    MAX_DENSITY  = lerp(0.25, 0.08, t);
  }

  // --- UI ------------------------------------------------------------
  const speedEl = document.getElementById('speed'); const speedLabel=document.getElementById('speedLabel');
  speedEl.oninput = ()=>{ SPEED=+speedEl.value; speedLabel.textContent=SPEED+'x'; };

  const mutEl = document.getElementById('mut'); const mutLabel=document.getElementById('mutLabel');
  mutEl.oninput = ()=>{ MUT_RATE=+mutEl.value; mutLabel.textContent=Math.round(MUT_RATE*100)+'%'; };

  const seedEl = document.getElementById('seedCount'); const seedLabel=document.getElementById('seedLabel');
  seedEl.oninput = ()=>{ seedLabel.textContent = seedEl.value; };

  const pxEl = document.getElementById('px'); const pxLabel=document.getElementById('pxLabel');
  pxEl.oninput = ()=>{ tile = +pxEl.value; pxLabel.textContent=tile; buildGrid(false); randomSeeds(+seedEl.value); };

  const extEl = document.getElementById('ext'); const extLabel=document.getElementById('extLabel');
  extEl.oninput = ()=>{ const t=+extEl.value; extLabel.textContent=t.toFixed(2); applyExtinction(t); buildGrid(false); randomSeeds(+seedEl.value); };

  document.getElementById('resetBtn').onclick = ()=>{ buildGrid(false); randomSeeds(+seedEl.value); };
  document.getElementById('intrudeBtn').onclick = ()=>{
    const cx=rint(cols), cy=rint(rows); const alien=new Uint8Array([8,5,1,1,8,5,7,1,5,8,1,6,5,1,1,8]);
    for(let i=0;i<20;i++) spawn(cx+rint(9)-4, cy+rint(9)-4, mutate(alien, 0.02));
  };

  // 캔버스 인터랙션
  cvs.addEventListener('click', (e)=>{
    const rect=cvs.getBoundingClientRect(); const x=Math.floor((e.clientX-rect.left)/tile); const y=Math.floor((e.clientY-rect.top)/tile);
    seedBlob(x,y, 8);
  });

  // 키보드: U = UI 토글, M = 렌더모드 토글
  addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='u'){ document.body.classList.toggle('hide-ui'); buildGrid(true); }
    if(k==='m'){ RENDER_MODE = (RENDER_MODE==='glow'?'pixel':'glow'); }
  });

  // init
  applyExtinction(+extEl.value);
  buildGrid(false); randomSeeds(+seedEl.value); loop();
})();
</script>
</body>
</html>
